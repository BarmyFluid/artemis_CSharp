<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Artemis Entity System Framework</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <link rel="stylesheet" href="stylesheets/default.css">
    <script src="javascripts/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
          <h1>Artemis</h1>
          <p>An Entity System Framework</p>
          <p class="view"><a href="https://github.com/thelinuxlich/artemis_CSharp">View the Project on GitHub <small>thelinuxlich/artemis_CSharp</small></a></p>
          <ul>
              <li><a href="https://github.com/thelinuxlich/starwarrior_CSharp/archive/master.zip">Download <strong>Example</strong></a></li>
              <li><a href="https://github.com/thelinuxlich/artemis_CSharp/zipball/master">Download <strong>ZIP File</strong></a></li>
              <li><a href="http://nuget.org/packages/Artemis/">Nuget <strong>Link</strong></a></li>
              <li><a href="https://github.com/thelinuxlich/artemis_CSharp">View On <strong>GitHub</strong></a></li>
          </ul>
      </header>
      <section id="description">
          <h3>Description</h3>
          Artemis is a high performance Entity System framework for games, <a href="http://gamadu.com/artemis">originally written in Java</a> by Arni Arent and Tiago Costa, now ported to C#. <br/>
          Its goal is to provide a clean API to abstract your game world organization into entities, components and systems.<br/>
          Artemis has no dependencies (for PC, in Xbox and Windows Phone 7 we have one) and can be used with any game framework or library, 2D or 3D, and even multiplatform, if you use it with Mono/MonoTouch/Mono4Android.
     </section>
     <section id="differences">
          <h3>Differences from the original version</h3>
          We support all the features included in the original Java version, but we've also added the following features:
          <ul>
              <li>Multithreading Support (two ways of doing this)</li>
              <li>Specialized System templates for your multithreading needs</li>
              <li>Communication between Systems using a Blackboard approach</li>
              <li>Bugs fixed, performance improvements</li>
              <li>Xbox/WP7/Mono(Android/Linux/Mac/iOS) support </li>
              <li>Events for intercepting adding/removal of entities/components</li>
              <li>Blackboard for sharing common objects between systems</li>
              <li>Entity Pool (to make objects reusable, minimize garbage collection activity, improve performance)</li>
              <li>Small goodies, like feeding the EntityWorld with whole Entities(maybe loading from external resources), enabling/disabling systems and entities, getting Entity tag, API shortcuts(see unit tests for more on this), etc.</li>
         </ul>
    </section>
    <section id="getting_started">
        <h3>Getting Started</h3>
        <ul>
            <li>Entities are only an aggregation of Components, identified by a unique id</li>
            <li>Components are only data</li>
            <li>Systems publish/subscribe to Components, creating behavior</li>
        </ul>
        There is much more to tell about this paradigm and we already have rich articles which inspired this framework. Some of them:
        <ul>
            <li><a href="http://t-machine.org/index.php/2007/09/03/entity-systems-are-the-future-of-mmog-development-part-1/">Entity Systems are the future of MMOG development</a></li>
            <li><a href="http://cowboyprogramming.com/2007/01/05/evolve-your-heirachy/">Evolve your Hierarchy</a></li>
            <li><a href="http://scottbilas.com/games/dungeon-siege">Scott Bilas post-mortem on Dungeon Siege development</a></li>
            <li><a href="http://gamesfromwithin.com/data-oriented-design">Data-Oriented Design</a></li>
        </ul>
        And many more can be found <a href="http://www.ploobs.com.br/forum/viewtopic.php?f=39&t=136">here.</a><br/><br/>
        Your components must inherit from the class Component or ComponentPoolable if you want it to use the Artemis Component Pool. Example:
        <div class="highlight">
        <pre lang="csharp"><code>//Add this Attribute and extend ComponentPoolable if you want your Component to use Artemis Component Pool
[Artemis.Attributes.ArtemisComponentPool(InitialSize=5,Resizes=true, ResizeSize=20, isSupportMultiThread=false)]
class Velocity : ComponentPoolable
{
        private float velocity;
        private float angle;

        public Velocity() { }

        public Velocity(float vector)
        {
            velocity = vector;
        }

        public Velocity(float velocity, float angle)
        {
            this.velocity = velocity;
            this.angle = angle;
        }

        public float Speed {
            get { return velocity;}
            set { velocity = value; }
        }

        public float Angle
        {
            get { return angle; }
            set { angle = value;}
        }

        public void AddAngle(float a)
        {
            angle = (angle + a) % 360;
        }

        public float AngleAsRadians
        {
            get { return (float)Math.PI * angle / 180.0f; }
        }

        //obligatory for poolable Components
        public void Cleanup()
        {
             coords = Vector3.Zero;
        }
}</code></pre>
        </div>
        A sample for entity assembling:
        <pre><code>Entity e = world.CreateEntity(); // you can pass an unique ID as first parameter.
e.AddComponent(new Transform(200,400));
e.AddComponentFromPool(new Velocity(2.4f,0.9f)); // use AddComponentFromPool if the Component extend from ComponentPoolable
e.Refresh();// always call Refresh() when adding/removing components!
        </code></pre>
        Your systems should inherit from one of the following templates:
        <ul>
            <li>EntitySystem - the simplest system template, not tied to components, good for stuff like collision</li>
            <li>EntityProcessingSystem - a template for processing many entities, tied to components</li>
            <li>IntervalEntitySystem - a simple system template, not tied to components, process periodically, based on world delta.</li>
            <li>IntervalEntityProcessingSystem - a template that process entities periodically, based on world delta, tied to components.</li>
            <li>ParallelEntityProcessingSystem - a template to leverage your multicore CPU for processing many entities, tied to components</li>
            <li>ProcessingSystem - a template that process whichever logic you desire, without being tied to components</li>
            <li>QueueProcessingSystem</li>
            <li>HybridQueueProcessingSystem</li>
            <li>QueueProcessingSystemThreadSafe</li>
            <li>FQueueSystemProcessingThreadSafe</li>
            <li>TagSystem - a simple system template, not tied to components, process a tagged entity</li>
            <li>IntervalTagSystem - a simple system template, not tied to components, process a tagged entity periodically, based on world delta.</li>
            <li>DelayedEntitySystem - a simple system template that starts process after a given time, based on world delta.</li>
            <li>DelayedEntityProcessingSystem - a template that starts processing entities after a given time, based on world delta. Tied to components</li>
        </ul>
        And here is a system example, using Velocity and Transform components to create the Movement behavior:
        <pre><code>//Add this attribute so the EntityWorld knows the systems it should execute, use the Layer to determine execution order
[Artemis.Attributes.ArtemisEntitySystem(ExecutionType = ExecutionType.UpdateSynchronous, Layer = 1)]
public class MovementSystem : EntityProcessingSystem {

    public MovementSystem() : base(Aspect.All(typeof(Transform), typeof(Velocity))) { }

    public override void Initialize() {}

    public override void Process(Entity e) {
        Velocity velocity = e.getComponent<Velocity>();
        float v = velocity.Speed;

        Transform transform = e.getComponent<Transform>();

        float r = velocity.AngleAsRadians;

        float xn = transform.X + (TrigLUT.Cos(r) * v * world.Delta);
        float yn = transform.Y + (TrigLUT.Sin(r) * v * world.Delta);

        transform.SetLocation(xn, yn);
    }
}</code></pre>
        On your game initialization, create a new EntityWorld and initialize it:
        <pre><code>var world = new EntityWorld();
world.InitializeAll(true); // pass true/false to enable/disable DataAttributes on Systems
        </code></pre>
        Update or Draw the World:
        <pre><code>world.Update();
world.Draw(); // do this on a different loop, e.g: every 60 frames.
        </code></pre>
        And you are good to go. The Entity object has some intuitive methods like Delete(), GetComponent(), RemoveComponent(), which
        you can see in action on the <a href="https://github.com/thelinuxlich/starwarrior_CSharp">example game.</a>
    </section>
	<section id="aspects">
		<h3>Aspects</h3>
		Aspects are used in the constructor of your entity systems to tell them which components they should be interested. At the moment we have three
		methods to build Aspects:
		<ul>
			<li>Aspect.All(params Type[] types) - Most of the time you will use this option, so the system processes entities which have all components of the Aspect.</li>
			<li>Aspect.One(params Type[] types) - The system will process entities which have at least one of the components of the Aspect.</li>
			<li>Aspect.Exclude(params Type[] types) - The system will not process entities which have at least one of the components of the Aspect.</li>
		</ul>
		You can also compose your Aspect utilizing these methods together, example:
		<pre><code>public LogEnemySystem() : base(Aspect.All(typeof(Health)).One(typeof(Koopa),typeof(Goomba),typeof(Magikoopa)).exclude(typeof(Ghost))) {}</code></pre>
	</section>
  <section id="extending_systems">
    <h3>Extending Systems</h3>
    It's quite simple to extend the EntitySystem with your own logic, an example can be found <a href="https://github.com/thelinuxlich/artemis_CSharp/blob/master/Artemis_XNA_INDEPENDENT/System/EntityComponentProcessingSystem.cs">here</a>, which gives us less setup on systems which only uses Aspect.All(), example:
    <pre>
      <code>[Artemis.Attributes.ArtemisEntitySystem(ExecutionType = ExecutionType.UpdateSynchronous, Layer = 1)]
public class MovementSystem : EntityComponentProcessingSystem<Transform,Velocity> {
    public override void Process(Entity e,Transform transform, Velocity velocity) {
        float v = velocity.Speed;
        float r = velocity.AngleAsRadians;

        float xn = transform.X + (TrigLUT.Cos(r) * v * world.Delta);
        float yn = transform.Y + (TrigLUT.Sin(r) * v * world.Delta);

        transform.SetLocation(xn, yn);
    }
}</code>
    </pre>
  </section>
	<section id="templates">
		<h3>Templates</h3>
		Create your entity templates to avoid manually creating and configuring entities:
		<pre><code>[Artemis.Attributes.ArtemisEntityTemplate("BulletExplosion")]
public EnemyTemplate : Artemis.IEntityTemplate {
	public Entity BuildEntity(Entity e,EntityWorld entityWorld, params object[] args) {
		e.AddComponent(new Transform(200,400));
		e.AddComponent(new Velocity(2.4f,0.9f));
	}
}</code></pre>
		Create your entities with the template applied:
		<pre><code>var enemy = world.CreateEntityFromTemplate("BulletExplosion",array_of_parameters); // you can also use an alternative signature passing a custom unique id as the first parameter.
enemy.Refresh();</code></pre>
	</section>
	<section id="blackboard">
	    <h3>Blackboard</h3>
	    You can easily share common objects between systems using the blackboard, here is a XNA example, on the game initialization:
	    <pre><code>EntitySystem.BlackBoard.SetEntry<ContentManager>("ContentManager", Content);
EntitySystem.BlackBoard.SetEntry<GraphicsDevice>("GraphicsDevice", GraphicsDevice);
EntitySystem.BlackBoard.SetEntry<SpriteBatch>("SpriteBatch", spriteBatch);</code></pre>
        Then you can retrieve the objects inside systems like this:
        <pre><code>this.device = EntitySystem.BlackBoard.GetEntry<GraphicsDevice>("GraphicsDevice");
this.spriteBatch = EntitySystem.BlackBoard.GetEntry<SpriteBatch>("SpriteBatch");
this.contentManager = EntitySystem.BlackBoard.GetEntry<ContentManager>("ContentManager");</code></pre>
	</section>
  <section id="games">
    <h3>Games created with Artemis C#</h3>
    <a href="http://tripleslashstudios.com/">Magnetic by Nature</a> - by Tripleslash Studios. They also have a <a href="http://www.kickstarter.com/projects/tripleslash/magnetic-by-nature">Kickstarter</a> running for the game, support it!
  </section>
  <section id="discussion">
      <h3>Discussion, issues, suggestions</h3>
      We have a forum section <a href="http://www.ploobs.com.br/forum/viewforum.php?f=39">here.</a>
  </section>
  </div>
  <footer>
      <p>Project maintained by <a href="https://github.com/thelinuxlich">thelinuxlich</a> and <a href="https://github.com/tpastor">tpastor</a></p>
  </footer>
  <!--[if !IE]><script>fixScale(document);</script><!--<![endif]-->
  </body>
</html>
